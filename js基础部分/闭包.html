<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1.0,user-scalable=no">
  <title> 闭包 闭包是指有权访问另外一个函数作用域中的变量的函数</title>
</head>
<body>
<!-- https://juejin.im/post/5dac5d82e51d45249850cd20#heading-23 -->
<script>
// ----------------------- 闭包有哪些表现形式? -----------------------------
  var a = 1;
  function foo(){
    var a = 2;
    function baz(){
        console.log(a);
    }
    bar(baz);
  }

  function bar(fn){
    // 这就是闭包
    fn();
  }
  
  foo();// 输出2，而不是1

  // ------- IIFE(立即执行函数表达式)创建闭包, 保存了全局作用域window和当前函数的作用域 ----------
  var a = 2;
  (function IIFE(){
    // 输出2
    console.log(a);
  })();
</script>

<script>
// ----------------------- 如何解决下面的循环输出问题? -----------------------------
for(var i = 1; i <= 5; i ++){
  setTimeout(function timer(){
    console.log(i)
  }, 0)
}
// 为什么会全部输出6？如何改进，让它输出1，2，3，4，5？
`因为setTimeout为宏任务，由于JS中单线程eventLoop机制，在主线程同步任务执行完后才去执行宏任务，
 因此循环结束后setTimeout中的回调才依次执行，但输出i的时候当前作用域没有，往上一级再找，发现了i,
 此时循环已经结束，i变成了6。因此会全部输出6。
`

// 解决方法
`1、利用IIFE(立即执行函数表达式)当每次for循环时，把此时的i变量传递到定时器中`
for(var i = 1;i <= 5;i++){
  (function(j){
    setTimeout(function timer(){
      console.log(j)
    }, 0)
  })(i)
}

`2、给定时器传入第三个参数, 作为timer函数的第一个函数参数`
// 可选。 传给执行函数的其他参数（IE9 及其更早版本不支持该参数）。
for(var i=1;i<=5;i++){
  setTimeout(function timer(j){
    console.log(j)
  }, 0, i)
}

`3、使用ES6中的let`
for(let i = 1; i <= 5; i++){
  setTimeout(function timer(){
    console.log(i)
  },0)
}


</script>

</body>
</html>

JS基础部分;
一. 执行上下文/作用域链/闭包;

1. 介绍一下js的执行上下文？
  执行上下文的3 种类型；
  全局执行上下文，浏览器的全局对象就是 window， this 指向这个全局对象；
  函数执行上下文：存在多个，只有在函数被调用的时候才会被创建，每次调用函数都会创建一个新的执行上下文；
  eavl 函数 运行在 eval 函数中 的  代码；

  执行栈 https://muyiy.cn/blog/1/1.1.html#%E6%89%A7%E8%A1%8C%E6%A0%88
  执行栈也叫调用栈，具有后进先出的结构， 用于存储在代码执行期间创建的所有执行上下文；
  首页运行 js 代码，会创建一个全局执行的上下文并 push 到当前的执行栈里面。 每次发生函数调用，
  引擎都会为本函数创建一个新的函数执行上下文并 push 到当前指向栈的栈顶。


1. js变量的存放？
  首先我们应该知道内存中有栈和堆，那么变量应该存放在哪里呢，堆？栈？
  (1)、基本类型 --> 保存在栈内存中，因为这些类型在内存中分别占有固定大小的空间，通过按值来访问。
  基本类型一共有6种：Undefined、Null、Boolean、Number 、String和Symbol;

  (2)、引用类型 --> 保存在堆内存中，因为这种值的大小不固定，因此不能把它们保存到栈内存中，
  但内存地址大小的固定的，因此保存在堆内存中，在栈内存中存放的只是该对象的访问地址。
  当查询引用类型的变量时， 先从栈中读取内存地址， 然后再通过地址找到堆中的值。对于这种，我们把它叫做按引用访问。
  在计算机的数据结构中，栈比堆的运算速度快，
  
  ``` js
    var a = 20;
    var b = a;
    b = 30; // 这时a的值是20？
    `a、b都是基本类型，它们的值是存储在栈中的，
     a、b分别有各自独立的栈空间，所以修改了b的值以后，a的值并不会发生变化。`
  ```

  ``` js
    var a = { name: '前端开发' }
    var b = a;
    b.name = '进阶'; // 这时a.name的值是 '进阶', 实际指向的是同一个对象.
    `a、b都是引用类型，栈内存中存放地址指向堆内存中的对象，引用类型的复制会为新的变量自动分配一个新的值保存在变量对象中，
     但只是引用类型的一个地址指针而已，实际指向的是同一个对象，所以修改b.name的值后，相应的a.name也就发生了改变。`
  ```

   ``` js
    var a = { name: '前端开发' }
    var b = a;
    a = null; // 这时b的值是多少  { name: '前端开发' }
    `首先要说明的是null是基本类型，a = null之后只是把a存储在栈内存中地址改变成了基本类型null，
     并不会影响堆内存中的对象，所以b的值不受影响。`

  ```

  ```js
    var a = {n: 1};
    var b = a;
    a.x = a = {n: 2}; 
    // Exp1 = Exp2 = Exp3 = Exp4
    // Ref1 = (Ref2 = (Ref3 = Value4))
    // 先从左到右解析各个引用，然后计算最右侧的表达式的值，最后把值从右到左赋给各个引用。

    a.x 	// 这时 a.x 的值是多少   // a {n: 2}
    b.x 	// 这时 b.x 的值是多少   // b {n: 1, x: {n: 2}}
    https://segmentfault.com/a/1190000004224719
    https://segmentfault.com/a/1190000018711603?utm_source=tag-newest
  ```


2. 内存空间管理?
  JavaScript的内存生命周期是

  (1)、分配你所需要的内存;
  (2)、使用分配到的内存（读、写）;
  (3)、不需要时将其释放、归还;
  JavaScript有自动垃圾收集机制，最常用的是通过标记清除的算法来找到哪些对象是不再继续使用的，
  使用a = null其实仅仅只是做了一个释放引用的操作，让 a 原本对应的值失去引用，脱离执行环境，
  这个值会在下一次垃圾收集器执行操作时被找到并释放。

  ## 内存的回收？
    JavaScript有自动垃圾收集机制，垃圾收集器会每隔一段时间就执行一次释放操作，
    找出那些不再继续使用的值，然后释放其占用的内存。
  局部变量和全局变量的销毁？
    1.局部变量：局部作用域中，当函数执行完毕，局部变量也就没有存在的必要了，
    因此垃圾收集器很容易做出判断并回收。
    2.全局变量：全局变量什么时候需要自动释放内存空间则很难判断，
    所以在开发中尽量避免使用全局变量。
  以Google的V8引擎为例，V8引擎中所有的JS对象都是通过 堆 来进行内存分配的
    初始分配：当声明变量并赋值时，V8引擎就会在堆内存中分配给这个变量。
    继续申请：当已申请的内存不足以存储这个变量时，V8引擎就会继续申请内存，直到堆的大小达到了V8引擎的内存上限为止。
  V8引擎对堆内存中的JS对象进行分代管理
    新生代：存活周期较短的JS对象，如临时变量、字符串等。
    老生代：经过多次垃圾回收仍然存活，存活周期较长的对象，如主控制器、服务器对象等。

  ## 垃圾回收算法；
  引用计数（现代浏览器不再使用）

  引用计数算法定义“内存不再使用”的标准很简单，就是看一个对象是否有指向它的引用。如果没有其他对象指向它了，说明该对象已经不再需要了。
  引用计数有一个致命的问题，那就是循环引用； 相互引用依然存在，因此这部分内存不会被回收。所以现代浏览器不再使用这个算法。

  标记清除（常用）
  标记清除算法将“不再使用的对象”定义为“无法到达的对象”。

  ## 内存泄漏识别方法？
   1、浏览器方法；
   2. 命令行方法；
   使用 Node 提供的 process.memoryUsage 方法。
   ```js
      console.log(process.memoryUsage());
      // 输出 
      { 
        rss: 27709440,		// resident set size，所有内存占用，包括指令区和堆栈
        heapTotal: 5685248,   // "堆"占用的内存，包括用到的和没用到的
        heapUsed: 3449392,	// 用到的堆的部分
        external: 8772 		// V8 引擎内部的 C++ 对象占用的内存
      }
   ```
  ## WeakMap
  ES6 新出的两种数据结构：WeakSet 和 WeakMap，
  表示这是弱引用，它们对于值的引用都是不计入垃圾回收机制的。

  ## 四种常见的js 内存泄露

  # 1、意外的全局变量
  ```js
    // 未定义的变量会在全局对象创建一个新变量，
    function foo(arg) {
      bar = "this is a hidden global variable";
    }

    // 函数 foo 内部忘记使用 var ，实际上JS会把bar挂载到全局对象上，意外创建一个全局变量。
    function foo(arg) {
      window.bar = "this is an explicit global variable";
    }

    // 另一个意外的全局变量可能由 this 创建。
    function foo() {
    this.variable = "potential accidental global";
    }

    // Foo 调用自己，this 指向了全局对象（window）而不是 undefined
    foo();
  ```
    ### 解决方法：
    在 JavaScript 文件头部加上 'use strict'，使用严格模式避免意外的全局变量，此时上例中的this指向undefined。
    如果必须使用全局变量存储大量数据时，确保用完以后把它设置为 null 或者重新定义。

  # 2.被遗忘的计时器或回调函数
  # 3.闭包

// ----2020年 7 月 13 日遗漏问题 js为什么数组放在堆内存里面？

3. 什么是闭包？
  闭包是指有权访问另外一个函数作用域中的变量的函数；关键在于下面两点：
    (1). 是一个函数
    (2). 能访问另外一个函数作用域中的变量

  ## 对于闭包有下面三个特性：
    1. 闭包可以访问当前函数以外的变量。
    2. 即使外部函数已经返回，闭包仍能访问外部函数定义的变量
    3. 闭包可以更新外部变量的值.


```js
  // 1.闭包可以访问当前函数以外的变量。
  function getOuter(){
    var date = '815';
    function getDate(str){
      console.log(str + date);  //访问外部的date
    }
    return getDate('今天是：'); //"今天是：815"
  }
  getOuter();


  // 2.即使外部函数已经返回，闭包仍能访问外部函数定义的变量
  function getOuter(){
    var date = '815';
    function getDate(str){
      console.log(str + date);  //访问外部的date
    }
    return getDate;     //外部函数返回
  }
  var today = getOuter();
  today('今天是：');   //"今天是：815"
  today('明天不是：');   //"明天不是：815"


  // 3. 闭包可以更新外部变量的值.
  function updateCount(){
    var count = 0;
    function getCount(val){
      count = val;
      console.log(count);
    }
    return getCount;     //外部函数返回
  }
  var count = updateCount();
  count(815); //815
  count(816); //816
```

```js
  function add(...args) {
    return args.reduce((a, b) => a + b);
  }

  function crrry(fn){
    let args = [];
    return function temp(...newArgs){
      if(!!newArgs.length){
        args= [
          ...args,
          ...newArgs
        ]

        return temp
      } else{
        let val = fn.apply(this,args);
        console.log('val',val)

        args = [];
        return val
      }
    }
  }

  let add1 = crrry(add)

  add1(1)(2)(3)()
  console.log(add1(1)(2)(3));
```
